为了准备面试，看了这么多关于继承的文章，好像都是一个模子里面出来的...所以总结一下自己的认识，希望能够让自己或者看到这篇文的你都有所收获。有什么不对的地方，请指正，我也会后续修改。

我会尽量写的清楚一些，来让这篇文章更容易理解。但是仍然需要你对以下几个方面有一定的基础。
```
1. '继承'(请注意，这可是带有引号的！)
2. call()和apply()
3. 原型链
4. 构造函数
5. 汉语...
```
首先来了解一下我们开始前的工作

## 继承
这里继承带有引号，因为继承是类中的说法，他的意思是复制！复制！复制！而JS中的'继承'，其实指的是通过原型链进行委托。不管怎么说，它本质上都不是复制，会和类的行为不一致。
## call()和apply()
call和apply方法可以将函数中的this指向我们需要的对象，比如说：
```JavaScript
function balabala() {
  this.name = 'balabala'
};
const obj = {};
balabala.call(obj)
obj.name // balabala
```
调用函数的时候使用call可以讲函数中的this指向obj，这个时候，obj就有了name属性，属性值是balabala。

## 原型链
JS万物皆是对象（如果你非要拿4种简单基本类型来怼我，对不起，请出门右转），而每个对象都有一个prototype属性。

举个栗子：

我们有一个A对象，A.prototype属性指向的其实也是一个对象，他就是我们委托的对象。所有的对象会通过prototype链一节一节的委托到起，一直到他的尽头Object.prototype，因为当我们的链子到达这一节的时候，此时的Object.prototype对象已经不再委托给任何对象了。

## new 函数

JS中通常使用new关键字调用构造函数来创建一个对象。  
通过new操作，主要实现了以下4个行为
```
1. new调用一个函数会生成一个新对象。
2. 新对象的原型对象会委托到我们函数的原型对象上来。
3. 新对象会指向被调用的函数中的this。
4. 如果被调用的函数中没有返回别的对象，那么就会返回这个新对象。
```
具体用法和理解参考以下栗子

网上给出很多种继承方式，有的六七种，这些个代号，反正我的脑细胞是记不下来...

我认为具体使用哪种继承，还是要看你业务的实际情况，你需要那种继承，就使用哪种继承。起名字是一件很复杂的事情，所以我这里不会给他们起任何名字。但是我会根据业务需要进行分门别类。

首先我们来创建一个父类
```javascript
function father() {
  this.name = 'Daddy';
}
father.prototype.spell = function() {
  console.log(this.name + ' from prototype');
}
const obj = new father();
```
father类中属性，会通过new调用以后，成为实例obj的属性，因此这个时候obj就有了name和speak属性。

同时由于obj的原型对象会指向father.prototype对象，因此obj可以通过原型使用father.prototype中的spell属性。

下面我们加入子类的情况，其中子类是通过父类实现的。




